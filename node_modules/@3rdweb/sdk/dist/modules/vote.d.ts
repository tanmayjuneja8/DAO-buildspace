import { VotingGovernor } from "@3rdweb/contracts";
import { TransactionReceipt } from "@ethersproject/providers";
import { BigNumber } from "ethers";
import { Currency, CurrencyValue, ModuleType } from "../common";
import { Module } from "../core/module";
import { MetadataURIOrObject } from "../core/types";
import { VoteType } from "../enums";
import { Proposal, ProposalExecutable } from "../types/vote";
export interface VoteSettings {
    votingDelay: string;
    votingPeriod: string;
    votingTokenAddress: string;
    votingTokenMetadata: Currency;
    votingQuorumFraction: string;
    proposalTokenThreshold: string;
}
/**
 * Access this module by calling {@link ThirdwebSDK.getVoteModule}
 *
 * @alpha
 * @public
 */
export declare class VoteModule extends Module<VotingGovernor> {
    static moduleType: ModuleType;
    /**
     * @internal
     */
    protected connectContract(): VotingGovernor;
    /**
     * @internal
     */
    protected getModuleType(): ModuleType;
    settings(): Promise<VoteSettings>;
    /**
     * Get a proposal by id.
     *
     * @param proposalId - The proposal id to get.
     * @returns - The proposal.
     */
    get(proposalId: string): Promise<Proposal>;
    /**
     * Returns all the proposals in the contract.
     *
     * @returns - All the proposals in the contract.
     */
    getAll(): Promise<Proposal[]>;
    /**
     * Create a new proposal.
     *
     * @param description - The description of the proposal.
     * @param executions - A set of executable transactions that will be run if the proposal is passed and executed.
     * @returns - The id of the created proposal.
     */
    propose(description: string, executions: ProposalExecutable[]): Promise<BigNumber>;
    /**
     * Vote on a proposal.
     *
     * @param proposalId - The proposal to cast a vote on.
     * @param voteType - The position the voter is taking on their vote.
     * @param reason - (optional) The reason for the vote.
     */
    vote(proposalId: string, voteType: VoteType, reason?: string): Promise<void>;
    /**
     * Checks if an account has voted on a proposal
     *
     * @param proposalId - The unique identifier of a proposal .
     * @param account - (optional) wallet account address. Defaults to connected signer.
     * @returns - True if the account has already voted on the proposal.
     */
    hasVoted(proposalId: string, account?: string): Promise<boolean>;
    /**
     * Once the voting period has ended, call this method to execute the executables in the proposal.
     *
     * @param proposalId - The proposal id to execute.
     */
    execute(proposalId: string): Promise<void>;
    /**
     * Check to see if a proposal can be executed.
     *
     * @param proposalId - The proposal ID to check.
     * @returns - True if the proposal can be executed, false otherwise.
     */
    canExecute(proposalId: string): Promise<boolean>;
    /**
     * Check the balance of the project wallet in the native token of the chain
     *
     * @returns - The balance of the project in the native token of the chain
     */
    balance(): Promise<CurrencyValue>;
    /**
     * Check the balance of the project wallet in a particular
     * ERC20 token contract
     *
     * @returns - The balance of the project in the native token of the chain
     */
    balanceOfToken(tokenAddress: string): Promise<CurrencyValue>;
    setModuleMetadata(metadata: MetadataURIOrObject): Promise<TransactionReceipt>;
    /**
     * Find a proposal by its id.
     *
     * @internal
     * @param proposalId - Proposal to check for
     */
    private ensureExists;
}
