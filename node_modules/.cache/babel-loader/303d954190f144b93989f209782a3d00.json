{"ast":null,"code":"import { Any } from \"./any\";\nimport { OperationMode, PropertyConvertingMode, PropertyMatchingRule, ValueCheckingMode } from \"./json-convert-enums\";\nimport { Settings } from \"./json-convert-options\";\n/**\n * Offers a simple API for mapping JSON objects to TypeScript/JavaScript classes and vice versa.\n *\n * @see https://www.npmjs.com/package/json2typescript full documentation on NPM\n */\n\nvar JsonConvert =\n/** @class */\nfunction () {\n  /////////////////\n  // CONSTRUCTOR //\n  /////////////////\n\n  /**\n   * Constructor.\n   *\n   * To learn more about the params, check the documentation of the equally named class properties.\n   *\n   * @param operationMode optional param (default: OperationMode.ENABLE)\n   * @param valueCheckingMode optional param (default: ValueCheckingMode.ALLOW_OBJECT_NULL)\n   * @param ignorePrimitiveChecks optional param (default: false)\n   * @param propertyMatchingRule optional param (default: PropertyMatchingRule.CASE_STRICT)\n   */\n  function JsonConvert(operationMode, valueCheckingMode, ignorePrimitiveChecks, propertyMatchingRule) {\n    ////////////////\n    // PROPERTIES //\n    ////////////////\n\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     */\n    this._operationMode = OperationMode.ENABLE;\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     */\n\n    this._valueCheckingMode = ValueCheckingMode.ALLOW_OBJECT_NULL;\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     */\n\n    this._mapUndefinedToNull = false;\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     */\n\n    this._ignorePrimitiveChecks = false;\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     */\n\n    this._propertyMatchingRule = PropertyMatchingRule.CASE_STRICT;\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     */\n\n    this._propertyConvertingMode = undefined;\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n\n    this._useDiscriminator = false;\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n\n    this._discriminatorPropertyName = \"$type\";\n    /**\n     * Determines all classes which should use the discriminator feature.\n     * Only classes provided here can be enriched with the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n\n    this._classes = new Map();\n    if (operationMode !== undefined && operationMode in OperationMode) this.operationMode = operationMode;\n    if (valueCheckingMode !== undefined && valueCheckingMode in ValueCheckingMode) this.valueCheckingMode = valueCheckingMode;\n    if (ignorePrimitiveChecks !== undefined) this.ignorePrimitiveChecks = ignorePrimitiveChecks;\n    if (propertyMatchingRule !== undefined) this.propertyMatchingRule = propertyMatchingRule;\n  }\n\n  Object.defineProperty(JsonConvert.prototype, \"operationMode\", {\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._operationMode;\n    },\n\n    /**\n     * Determines how the JsonConvert class instance should operate.\n     *\n     * You may assign three different values:\n     * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n     * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n     * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in OperationMode) this._operationMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"valueCheckingMode\", {\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._valueCheckingMode;\n    },\n\n    /**\n     * Determines which types are allowed to be null.\n     * This setting may be overridden by property settings (see PropertyConvertingMode).\n     *\n     * You may assign three different values:\n     * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n     * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n     * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in ValueCheckingMode) this._valueCheckingMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"mapUndefinedToNull\", {\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._mapUndefinedToNull;\n    },\n\n    /**\n     * Determines whether a missing or undefined property value should be considered as null or not.\n     *\n     * If true, a missing JSON value will be added and set as null before deserialization.\n     * For serialization, undefined values will be set to null before serialization.\n     *\n     * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n     * serialization or deserialization.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._mapUndefinedToNull = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"ignorePrimitiveChecks\", {\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._ignorePrimitiveChecks;\n    },\n\n    /**\n     * Determines whether primitive types should be checked.\n     * If true, it will be allowed to assign primitive to other primitive types.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._ignorePrimitiveChecks = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"propertyMatchingRule\", {\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._propertyMatchingRule;\n    },\n\n    /**\n     * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n     *\n     * You may assign the following values:\n     * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n     * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n     * are not case sensitive\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      if (value in PropertyMatchingRule) this._propertyMatchingRule = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"propertyConvertingMode\", {\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._propertyConvertingMode;\n    },\n\n    /**\n     * Determines how nullable property types should be serialized and deserialized.\n     * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n     *\n     * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n     *\n     * The values should be used as follows:\n     * - MAP_NULLABLE: the mapper is applied, type is checked\n     * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * not added to the result\n     * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n     * added with its value to the result\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._propertyConvertingMode = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"ignoreRequiredCheck\", {\n    /**\n     * @deprecated\n     */\n    get: function () {\n      return this.propertyConvertingMode === PropertyConvertingMode.IGNORE_NULLABLE;\n    },\n\n    /**\n     * @deprecated\n     */\n    set: function (value) {\n      this.propertyConvertingMode = value ? PropertyConvertingMode.IGNORE_NULLABLE : undefined;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"useDiscriminator\", {\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._useDiscriminator;\n    },\n\n    /**\n     * Determines if discriminators should be used.\n     * If this option is set to true, all registered classes will be serialized with an additional discriminator\n     * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n     * When deserializing an object containing the discriminator property, json2typescript will attempt to\n     * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n     * registered classes).\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._useDiscriminator = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"discriminatorPropertyName\", {\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._discriminatorPropertyName;\n    },\n\n    /**\n     * Defines the name of the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    set: function (value) {\n      this._discriminatorPropertyName = value;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(JsonConvert.prototype, \"classes\", {\n    /**\n     * Determines all classes which should use the discriminator feature.\n     * Only classes provided here can be enriched with the discriminator property.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    get: function () {\n      return this._classes;\n    },\n    enumerable: false,\n    configurable: true\n  }); ////////////////////\n  // PUBLIC METHODS //\n  ////////////////////\n\n  /**\n   * Registers a list of classes to be used in the discriminator feature.\n   * After registering these classes, they may be used for the discriminator feature.\n   *\n   * @param classReferences the class references\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n  JsonConvert.prototype.registerClasses = function () {\n    var _this = this;\n\n    var classReferences = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      classReferences[_i] = arguments[_i];\n    }\n\n    classReferences.forEach(function (classReference) {\n      var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n\n      if (key) {\n        _this.classes.set(key, classReference);\n      }\n    });\n  };\n  /**\n   * Unregisters a list of classes from the discriminator feature.\n   * After unregistering these classes, they cannot be used anymore for the discriminator feature.\n   *\n   * @param classReferences the class references\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.unregisterClasses = function () {\n    var _this = this;\n\n    var classReferences = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      classReferences[_i] = arguments[_i];\n    }\n\n    classReferences.forEach(function (classReference) {\n      var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n\n      _this.classes.delete(key);\n    });\n  };\n  /**\n   * Unregisters all classes from discriminator feature.\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.unregisterAllClasses = function () {\n    this.classes.clear();\n  };\n  /**\n   * Tries to serialize a TypeScript object or array of objects to JSON using the mappings defined on\n   * the specified class reference. Note that if a class reference is provided, it will be used as\n   * the source of property mapping for serialization, even if the object or one of its elements is\n   * an instance of a different class with its own mappings.  Also, ONLY the properties from the\n   * class reference will be serialized - any additional properties on the object(s) will be silently\n   * ignored.\n   *\n   * @param data object or array of objects\n   * @param classReference the class reference which provides the property mappings to use\n   *\n   * @returns the JSON object\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.serialize = function (data, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return data;\n    } // Call the appropriate method depending on the type\n\n\n    if (data instanceof Array) {\n      return this.serializeArray(data, classReference);\n    } else if (typeof data === \"object\") {\n      // careful: an array is an object in TypeScript!\n      return this.serializeObject(data, classReference);\n    } else {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter data in JsonConvert.serialize() is not in valid format (object or array).\" + \"\\n\");\n    }\n  };\n  /**\n   * Tries to serialize a TypeScript object to a JSON object using either the mappings on the\n   * provided class reference, if present, or on the provided object. Note that if a class\n   * reference is provided, it will be used as the source of property mapping for serialization,\n   * even if the object is itself an instance of a different class with its own mappings.\n   * Also, ONLY the properties from the class reference will be serialized - any additional\n   * properties on the object will be silently ignored.\n   *\n   * @param data object containing the values to be mapped to a JSON object, must be an\n   *             instance of a class with JSON mappings if no class reference is provided\n   * @param classReference optional class reference which provides the property mappings to use\n   *\n   * @returns the JSON object\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.serializeObject = function (data, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return data;\n    }\n\n    data = this.mapUndefinedToNull && data === undefined ? null : data; // Check if the passed type is allowed\n\n    if (data === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (data === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return data;\n      }\n    } else if (typeof data !== \"object\" || data instanceof Array) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instance in JsonConvert.serializeObject() is not of type object.\" + \"\\n\");\n    } // Now serialize and return the plain object\n\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JavaScript instance:\");\n      console.log(data);\n    }\n\n    var jsonObject = {};\n    var instance;\n\n    if (!!classReference) {\n      instance = new classReference();\n    } else {\n      instance = data;\n    } // Loop through all initialized class properties on the mapping instance\n\n\n    for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n      var propertyKey = _a[_i];\n\n      try {\n        this.serializeObject_loopProperty(data, instance, propertyKey, jsonObject);\n      } catch (ex) {\n        if (this.operationMode === OperationMode.LOGGING) {\n          console.log(\"Failed to serialize property:\");\n          console.log(ex);\n          console.log(\"----------\");\n        }\n\n        throw ex;\n      }\n    }\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning JSON object:\");\n      console.log(jsonObject);\n      console.log(\"----------\");\n    }\n\n    return jsonObject;\n  };\n  /**\n   * Tries to serialize a TypeScript array to a JSON array using either the mappings on the\n   * provided class reference, if present, or on the provided object. Note that if a class\n   * reference is provided, ALL objects in the array will be serialized using the mappings\n   * from that class reference, even if they're actually instances of a different class.\n   * Also, ONLY the properties from the class reference will be serialized - any additional\n   * properties on the objects will be silently ignored.\n   *\n   * @param dataArray array of objects containing the values to be mapped to a JSON object, which\n   *                  must be instances of classes with JSON mappings if no class reference is provided\n   * @param classReference optional class reference which provides the property mappings to use\n   *\n   * @returns the JSON array\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.serializeArray = function (dataArray, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return dataArray;\n    }\n\n    dataArray = this.mapUndefinedToNull && dataArray === undefined ? null : dataArray; // Check if the passed type is allowed\n\n    if (dataArray === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (dataArray === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return dataArray;\n      }\n    } else if (typeof dataArray !== \"object\" || dataArray instanceof Array === false) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter instanceArray in JsonConvert.serializeArray() is not of type array.\" + \"\\n\");\n    } // Now serialize and return the plain object\n\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JavaScript array:\");\n      console.log(dataArray);\n    }\n\n    var jsonArray = []; // Loop through all array elements\n\n    for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {\n      var dataObject = dataArray_1[_i];\n      jsonArray.push(this.serializeObject(dataObject, classReference));\n    }\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning JSON array:\");\n      console.log(jsonArray);\n      console.log(\"----------\");\n    }\n\n    return jsonArray;\n  };\n  /**\n   * Tries to deserialize given JSON to a TypeScript object or array of objects.\n   *\n   * @param json the JSON as object or array\n   * @param classReference the class reference\n   *\n   * @returns the deserialized data (TypeScript instance or array of TypeScript instances)\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.deserialize = function (json, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return json;\n    } // Call the appropriate method depending on the type\n\n\n    if (json instanceof Array) {\n      return this.deserializeArray(json, classReference);\n    } else if (typeof json === \"object\") {\n      // careful: an array is an object in TypeScript!\n      return this.deserializeObject(json, classReference);\n    } else {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter json in JsonConvert.deserialize() is not in valid JSON format (object or array).\" + \"\\n\");\n    }\n  };\n  /**\n   * Tries to deserialize a JSON object to a TypeScript object.\n   *\n   * @param jsonObject the JSON object\n   * @param classReference the class reference\n   *\n   * @returns the deserialized TypeScript instance\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.deserializeObject = function (jsonObject, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return jsonObject;\n    }\n\n    jsonObject = this.mapUndefinedToNull && jsonObject === undefined ? null : jsonObject; // Check if the passed type is allowed\n\n    if (jsonObject === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (jsonObject === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return jsonObject;\n      }\n    } else if (typeof jsonObject !== \"object\" || jsonObject instanceof Array) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonObject in JsonConvert.deserializeObject() is not of type object.\" + \"\\n\");\n    } // Now deserialize and return the instance\n\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JSON object:\");\n      console.log(jsonObject);\n    }\n\n    var instance = new classReference(); // Loop through all initialized class properties\n\n    for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n      var propertyKey = _a[_i];\n\n      try {\n        this.deserializeObject_loopProperty(instance, propertyKey, jsonObject);\n      } catch (ex) {\n        if (this.operationMode === OperationMode.LOGGING) {\n          console.log(\"Failed to deserialize property:\");\n          console.log(ex);\n          console.log(\"----------\");\n        }\n\n        throw ex;\n      }\n    }\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning CLASS instance:\");\n      console.log(instance);\n      console.log(\"----------\");\n    }\n\n    return instance;\n  };\n  /**\n   * Tries to deserialize a JSON array to a TypeScript array.\n   *\n   * @param jsonArray the JSON array\n   * @param classReference the object class\n   *\n   * @returns the deserialized array of TypeScript instances\n   *\n   * @throws an Error in case of failure\n   *\n   * @see https://www.npmjs.com/package/json2typescript full documentation\n   */\n\n\n  JsonConvert.prototype.deserializeArray = function (jsonArray, classReference) {\n    if (this.operationMode === OperationMode.DISABLE) {\n      return jsonArray;\n    }\n\n    jsonArray = this.mapUndefinedToNull && jsonArray === undefined ? null : jsonArray; // Check if the passed type is allowed\n\n    if (jsonArray === undefined) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" + \"\\n\");\n    } else if (jsonArray === null) {\n      if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n        throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeObject() is null. You have specified to \" + \"disallow null values.\" + \"\\n\");\n      } else {\n        return jsonArray;\n      }\n    } else if (typeof jsonArray !== \"object\" || jsonArray instanceof Array === false) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Passed parameter jsonArray in JsonConvert.deserializeArray() is not of type array.\" + \"\\n\");\n    } // Now deserialize and return the array\n\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"----------\");\n      console.log(\"Receiving JSON array:\");\n      console.log(jsonArray);\n    }\n\n    var array = []; // Loop through all array elements\n\n    for (var _i = 0, jsonArray_1 = jsonArray; _i < jsonArray_1.length; _i++) {\n      var jsonObject = jsonArray_1[_i];\n      array.push(this.deserializeObject(jsonObject, classReference));\n    }\n\n    if (this.operationMode === OperationMode.LOGGING) {\n      console.log(\"Returning array of CLASS instances:\");\n      console.log(array);\n      console.log(\"----------\");\n    }\n\n    return array;\n  }; /////////////////////\n  // PRIVATE METHODS //\n  /////////////////////\n\n  /**\n   * Tries to find the JSON mapping for a given class property from the given instance used for mapping,\n   * and finally assign the value from the given dataObject\n   *\n   * @param dataObject the object containing the value to be assigned\n   * @param instance the instance of the class used for mapping\n   * @param classPropertyName the property name\n   * @param json the JSON object\n   * @throws throws an Error in case of failure\n   */\n\n\n  JsonConvert.prototype.serializeObject_loopProperty = function (dataObject, instance, classPropertyName, json) {\n    var _this = this;\n\n    var _a, _b; // Check if a JSON-object mapping is possible for a property\n\n\n    var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n\n    if (mappingOptions === null) {\n      return;\n    } // Get expected and real values\n\n\n    var jsonPropertyName = mappingOptions.jsonPropertyName;\n    var expectedJsonType = mappingOptions.expectedJsonType;\n    var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n    var customConverter = mappingOptions.customConverter;\n    var classInstancePropertyValue = dataObject[classPropertyName]; // Check if we have a nullable type\n\n    classInstancePropertyValue = this.mapUndefinedToNull && classInstancePropertyValue === undefined ? null : classInstancePropertyValue;\n\n    if (classInstancePropertyValue === undefined || classInstancePropertyValue === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return;\n      }\n\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        json[jsonPropertyName] = classInstancePropertyValue;\n        return;\n      }\n    } // Map the property\n\n\n    try {\n      json[jsonPropertyName] = customConverter !== null ? customConverter.serialize(classInstancePropertyValue) : this.convertProperty(expectedJsonType, classInstancePropertyValue, convertingMode, true);\n      var classConstructorName_1 = (_b = dataObject === null || dataObject === void 0 ? void 0 : dataObject.constructor) === null || _b === void 0 ? void 0 : _b.name;\n\n      if (this._useDiscriminator && json instanceof Object) {\n        this.classes.forEach(function (classDataObject, key) {\n          if (classDataObject.name === classConstructorName_1) {\n            json[_this._discriminatorPropertyName] = key;\n          }\n        });\n      }\n    } catch (e) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Failed to map the JavaScript instance of class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" to JSON because of a type error.\\n\\n\" + \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" + \"\\tClass property value: \\n\\t\\t\" + classInstancePropertyValue + \"\\n\\n\" + \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" + \"\\tRuntime type: \\n\\t\\t\" + this.getTrueType(classInstancePropertyValue) + \"\\n\\n\" + \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" + e.message + \"\\n\");\n    }\n  };\n  /**\n   * Tries to find the JSON mapping for a given class property and finally assign the value.\n   *\n   * @param instance the instance of the class\n   * @param classPropertyName the property name\n   * @param json the JSON object\n   *\n   * @throws throws an Error in case of failure\n   */\n\n\n  JsonConvert.prototype.deserializeObject_loopProperty = function (instance, classPropertyName, json) {\n    var _a;\n\n    var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n\n    if (mappingOptions === null) {\n      return;\n    } // Get expected and real values\n\n\n    var jsonPropertyName = mappingOptions.jsonPropertyName;\n    var expectedJsonType = mappingOptions.expectedJsonType;\n    var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n    var customConverter = mappingOptions.customConverter;\n    var jsonValue = undefined;\n\n    try {\n      jsonValue = this.getObjectValue(json, jsonPropertyName);\n    } catch (_b) {} // Check if we have a nullable type\n\n\n    jsonValue = this.mapUndefinedToNull && jsonValue === undefined ? null : jsonValue;\n\n    if (jsonValue === undefined || jsonValue === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return;\n      }\n\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        instance[classPropertyName] = jsonValue;\n        return;\n      }\n    } // Map the property\n\n\n    try {\n      var classConstructorName = jsonValue instanceof Object ? jsonValue[this.discriminatorPropertyName] : null;\n\n      if (this._useDiscriminator && this.classes.has(classConstructorName)) {\n        expectedJsonType = this.classes.get(classConstructorName);\n      }\n\n      instance[classPropertyName] = customConverter !== null ? customConverter.deserialize(jsonValue) : this.convertProperty(expectedJsonType, jsonValue, convertingMode);\n    } catch (e) {\n      throw new Error(\"Fatal error in JsonConvert. \" + \"Failed to map the JSON object to the class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" because of a type error.\\n\\n\" + \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" + \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" + \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" + \"\\tJSON type: \\n\\t\\t\" + this.getJsonType(jsonValue) + \"\\n\\n\" + \"\\tJSON value: \\n\\t\\t\" + JSON.stringify(jsonValue) + \"\\n\\n\" + e.message + \"\\n\");\n    }\n  }; ////////////////////\n  // HELPER METHODS //\n  ////////////////////\n\n  /**\n   * Gets the mapping options of a given class property.\n   *\n   * @param instance any class instance\n   * @param {string} propertyName any property name\n   *\n   * @returns {MappingOptions|null}\n   */\n\n\n  JsonConvert.prototype.getClassPropertyMappingOptions = function (instance, propertyName) {\n    var mappings = instance[Settings.MAPPING_PROPERTY]; // Check if mapping is defined\n\n    if (typeof mappings === \"undefined\") return null;\n    /* Find mapping by iterating up the prototype chain to find a matching mapping, rather than\n     * just searching by property name. */\n\n    var prototype = Object.getPrototypeOf(instance);\n    /* According to documentation, we'll hit null when we've iterated all the way up to the base\n     * Object, but check for undefined as well in case prototype has been manually set to\n     * undefined. Note that javascript detects circular prototype references and will cause a\n     * TypeError, so no need to check for self, the prototype chain will eventually terminate. */\n\n    while (prototype !== null && prototype !== undefined) {\n      var classIdentifier = prototype[Settings.CLASS_IDENTIFIER];\n\n      if (!!classIdentifier) {\n        var mappingName = classIdentifier + \".\" + propertyName;\n\n        if (typeof mappings[mappingName] !== \"undefined\") {\n          return mappings[mappingName];\n        }\n      }\n\n      prototype = Object.getPrototypeOf(prototype);\n    }\n\n    return null;\n  };\n  /**\n   * Compares the type of a given value with an internal expected json type.\n   * Either returns the resulting value or throws an exception.\n   *\n   * @param expectedType the expected type for the property\n   * @param value the property value to verify\n   * @param convertingMode the converting mode for this property\n   * @param serialize optional param (default: false), if given, we are in serialization mode\n   *\n   * @returns returns the resulted mapped property\n   *\n   * @throws an error in case of failure\n   */\n\n\n  JsonConvert.prototype.convertProperty = function (expectedType, value, convertingMode, serialize) {\n    ////////////////////////////\n    // Prior checks and setup //\n    ////////////////////////////\n    // Return the value immediately if we don't care about the type\n    if (expectedType === undefined || expectedType === Any || expectedType === null || expectedType === Object) {\n      return value;\n    } // Check if we have a nullable type\n\n\n    value = this.mapUndefinedToNull && value === undefined ? null : value;\n\n    if (value === undefined || value === null) {\n      if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n        return undefined;\n      }\n\n      if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n        return value;\n      }\n    }\n\n    var expectedDimension = \"1\";\n\n    if (expectedType instanceof Array) {\n      expectedDimension = \"2\";\n    }\n\n    var valueDimension = \"1or2\";\n\n    if (value instanceof Array) {\n      valueDimension = \"2\";\n    } else if (!(value instanceof Object)) {\n      valueDimension = \"1\";\n    }\n\n    if (expectedDimension === \"1\" && valueDimension === \"2\") {\n      throw new Error(\"\\tReason: Expected a non-array type, but given value is an array.\");\n    }\n\n    if (expectedDimension === \"2\" && valueDimension === \"1\") {\n      // Allow to use null in the special case\n      if (value === null && this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n        return null;\n      } else if (value === null) {\n        throw new Error(\"\\tReason: Expected an array, but given value is null.\");\n      }\n\n      throw new Error(\"\\tReason: Expected an array, but given value is a primitive type.\");\n    } //////////////////\n    // Check values //\n    //////////////////\n\n\n    if (expectedDimension === \"2\" && (valueDimension === \"2\" || valueDimension === \"1or2\")) {\n      // Return an empty array if we have an empty array or object as value\n      if (value.length === 0 || Object.keys(value).length === 0) {\n        return [];\n      } // Return the value if we don't care about the array type\n\n\n      if (expectedType.length === 0) {\n        return value;\n      } // Copy the expectedJsonType array so we don't change the class-level mapping based on the value of this property\n\n\n      var jsonType = expectedType.slice(0);\n      var array = [];\n\n      if (valueDimension === \"2\") {\n        // Loop through the data. Both type and value are at least of length 1\n        var autofillType = jsonType.length < value.length;\n\n        for (var i = 0; i < value.length; i++) {\n          if (autofillType && i >= jsonType.length) {\n            jsonType[i] = jsonType[i - 1];\n          }\n\n          array[i] = this.convertProperty(jsonType[i], value[i], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n        }\n\n        return array;\n      } else {\n        // Loop through the data. Both type and value are at least of length 1\n        var autofillType = jsonType.length < Object.keys(value).length;\n        var i = 0;\n\n        for (var key in value) {\n          if (autofillType && i >= jsonType.length) {\n            jsonType[i] = jsonType[i - 1];\n          }\n\n          array[key] = this.convertProperty(jsonType[i], value[key], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n          i++;\n        }\n\n        return array;\n      }\n    } else if (expectedDimension === \"1\" && (valueDimension === \"1\" || valueDimension === \"1or2\")) {\n      // Check if objects match\n      if (expectedType instanceof Object && value instanceof Object) {\n        if (expectedType.prototype.hasOwnProperty(Settings.CLASS_IDENTIFIER)) {\n          return serialize ? this.serializeObject(value, expectedType) : this.deserializeObject(value, expectedType);\n        } else {\n          return value;\n        }\n      } else {\n        // Check for null values\n        if (value === null) {\n          if (expectedType === String || expectedType === Number || expectedType === Boolean) {\n            if (this.valueCheckingMode === ValueCheckingMode.ALLOW_NULL) {\n              return null;\n            } else {\n              throw new Error(\"\\tReason: Given value null does not match the expected primitive type.\");\n            }\n          } else {\n            if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n              return null;\n            } else {\n              throw new Error(\"\\tReason: Given value null does not match the expected object type.\");\n            }\n          }\n        } // Check for primitive matches\n\n\n        if (expectedType === String && typeof value === \"string\" || expectedType === Number && typeof value === \"number\" || expectedType === Boolean && typeof value === \"boolean\") {\n          return value;\n        } else {\n          if (this.ignorePrimitiveChecks) return value;\n          throw new Error(\"\\tReason: Given value type does not match the expected primitive type.\");\n        }\n      }\n    }\n\n    console.log(\"---------2\");\n    console.log(expectedDimension);\n    console.log(expectedType);\n    console.log(valueDimension);\n    console.log(value); // All other attempts are fatal\n\n    throw new Error(\"\\tReason: Mapping failed because of an unknown error.\");\n    /*\n            // Map immediately if we don't care about the type\n            if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) {\n                return value;\n            }\n    \n            // Map the property to null if necessary\n            if (value === undefined && this.mapUndefinedToNull) {\n                value = null;\n            }\n    \n            // Check if attempt and expected was 1-d\n            if (expectedJsonType instanceof Array === false && value instanceof Array === false) {\n    \n                // Check the type\n                if (typeof (expectedJsonType) !== \"undefined\" && expectedJsonType.prototype.hasOwnProperty(Settings.CLASS_IDENTIFIER)) { // only decorated custom objects have this injected property\n    \n                    // Check if we have null value\n                    if (value === null) {\n                        if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL)\n                            return null;\n                        else throw new Error(\"\\tReason: Given value is null.\");\n                    }\n    \n                    if (serialize) return this.serializeObject(value, expectedJsonType);\n                    else return this.deserializeObject(value, expectedJsonType);\n    \n                } else if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) { // general object\n    \n                    // Check if we have null value\n                    if (value === null) {\n                        if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL)\n                            return null;\n                        else throw new Error(\"\\tReason: Given value is null.\");\n                    }\n    \n                    return value;\n    \n                } else if (expectedJsonType === String || expectedJsonType === Number || expectedJsonType === Boolean) { // otherwise check for a primitive type\n    \n                    // Check if we have null value\n                    if (value === null) {\n                        if (this.valueCheckingMode === ValueCheckingMode.ALLOW_NULL) return null;\n                        else throw new Error(\"\\tReason: Given value is null.\");\n                    }\n    \n                    // Check if the types match\n                    if ( // primitive types match\n                        (expectedJsonType === String && typeof (value) === \"string\") ||\n                        (expectedJsonType === Number && typeof (value) === \"number\") ||\n                        (expectedJsonType === Boolean && typeof (value) === \"boolean\")\n                    ) {\n                        return value;\n                    } else { // primitive types mismatch\n                        if (this.ignorePrimitiveChecks) return value;\n                        throw new Error(\"\\tReason: Given object does not match the expected primitive type.\");\n                    }\n    \n                } else { // other weird types\n    \n                    throw new Error(\n                        \"\\tReason: Expected type is unknown. There might be multiple reasons for this:\\n\" +\n                        \"\\t- You are missing the decorator @JsonObject (for object mapping)\\n\" +\n                        \"\\t- You are missing the decorator @JsonConverter (for custom mapping) before your class definition\\n\" +\n                        \"\\t- Your given class is undefined in the decorator because of circular dependencies\"\n                    );\n    \n                }\n    \n            }\n    \n            // Check if expected was n-d\n            if (expectedJsonType instanceof Array) {\n                if (value === null) {\n                    if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) return null;\n                    else throw new Error(\"\\tReason: Given value is null.\");\n                }\n    \n                // Check that value is not primitive\n                if (value instanceof Object) {\n                    let array: any[] = [];\n    \n                    // No data given, so return empty value\n                    if (value.length === 0) {\n                        return array;\n                    }\n    \n                    // We obviously don't care about the type, so return the value as is\n                    if (expectedJsonType.length === 0) {\n                        return value;\n                    }\n                    // Copy the expectedJsonType array so we don't change the class-level mapping based on the value of this property\n                    const jsonType: any[] = expectedJsonType.slice(0);\n    \n                    // Check if attempt was n-d\n                    if (value instanceof Array) {\n    \n                        // Loop through the data. Both type and value are at least of length 1\n                        let autofillType: boolean = jsonType.length < value.length;\n                        for (let i = 0; i < value.length; i++) {\n    \n                            if (autofillType && i >= jsonType.length) {\n                                jsonType[i] = jsonType[i - 1];\n                            }\n    \n                            array[i] = this.verifyProperty(jsonType[i], value[i], serialize);\n    \n                        }\n    \n                        return array;\n    \n                    // Otherwise attempt was 1-d\n                    } else {\n    \n                        // Loop through the data. Both type and value are at least of length 1\n                        let autofillType: boolean = jsonType.length < Object.keys(value).length;\n                        let i = 0;\n                        for (let key in value) {\n    \n                            if (autofillType && i >= jsonType.length) {\n                                jsonType[i] = jsonType[i - 1];\n                            }\n    \n                            array[key as any] = this.verifyProperty(jsonType[i], value[key]);\n    \n                            i++;\n                        }\n    \n                        return array;\n    \n                    }\n    \n                } else {\n                    throw new Error(\"\\tReason: Expected type is array, but given value is primitive.\");\n                }\n            }\n    \n            // Check if attempt was n-d and expected as 1-d\n            if (value instanceof Array) {\n                throw new Error(\"\\tReason: Given value is array, but expected a non-array type.\");\n            }\n    \n            // All other attempts are fatal\n            throw new Error(\"\\tReason: Mapping failed because of an unknown error.\");\n    */\n  };\n  /**\n   * Gets the value of an object for a given value.\n   * If the object does not have the specific key, an Error is thrown.\n   *\n   * @param data\n   * @param key\n   *\n   * @returns returns the value\n   *\n   * @throws an Error in case of the key was not found in the object\n   */\n\n\n  JsonConvert.prototype.getObjectValue = function (data, key) {\n    // If we do not care about the case of the key, ad\n    if (this.propertyMatchingRule === PropertyMatchingRule.CASE_INSENSITIVE) {\n      // Create a mapping of the keys: keys[lowercase]=normalcase\n      var keyMapping = Object.keys(data).reduce(function (keys, key) {\n        keys[key.toLowerCase()] = key;\n        return keys;\n      }, {}); // Define the new key\n\n      key = keyMapping[key.toLowerCase()];\n    } // Throw an error if the key is not in the object\n\n\n    if (key in data === false) {\n      throw new Error();\n    }\n\n    return data[key];\n  }; ///////////////////////////\n  // JSON2TYPESCRIPT TYPES //\n  ///////////////////////////\n\n  /**\n   * Returns a string representation of the expected json type.\n   *\n   * @param expectedJsonType the expected type given from the decorator\n   *\n   * @returns {string} the string representation\n   */\n\n\n  JsonConvert.prototype.getExpectedType = function (expectedJsonType) {\n    var type = \"\";\n\n    if (expectedJsonType instanceof Array) {\n      type = \"[\";\n\n      for (var i = 0; i < expectedJsonType.length; i++) {\n        if (i > 0) type += \",\";\n        type += this.getExpectedType(expectedJsonType[i]);\n      }\n\n      type += \"]\";\n      return type;\n    } else {\n      if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) {\n        return \"any\";\n      } else if (expectedJsonType === String || expectedJsonType === Boolean || expectedJsonType === Number) {\n        return new expectedJsonType().constructor.name.toLowerCase();\n      } else if (typeof expectedJsonType === \"function\") {\n        return new expectedJsonType().constructor.name;\n      } else if (expectedJsonType === undefined) {\n        return \"undefined\";\n      } else {\n        return \"?????\";\n      }\n    }\n  };\n  /**\n   * Returns a string representation of the JSON value type.\n   *\n   * @param jsonValue the JSON value\n   *\n   * @returns {string} the string representation\n   */\n\n\n  JsonConvert.prototype.getJsonType = function (jsonValue) {\n    if (jsonValue === null) return \"null\";\n    var type = \"\";\n\n    if (jsonValue instanceof Array) {\n      type = \"[\";\n\n      for (var i = 0; i < jsonValue.length; i++) {\n        if (i > 0) type += \",\";\n        type += this.getJsonType(jsonValue[i]);\n      }\n\n      type += \"]\";\n      return type;\n    } else {\n      return typeof jsonValue;\n    }\n  };\n  /**\n   * Returns a string representation of the true TypeScript type.\n   *\n   * @param trueValue the true value\n   *\n   * @returns {string} the string representation\n   */\n\n\n  JsonConvert.prototype.getTrueType = function (trueValue) {\n    return typeof trueValue;\n  };\n\n  return JsonConvert;\n}();\n\nexport { JsonConvert };","map":{"version":3,"sources":["../../../../src/json2typescript/json-convert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Any } from \"./any\";\nimport { OperationMode, PropertyConvertingMode, PropertyMatchingRule, ValueCheckingMode } from \"./json-convert-enums\";\nimport { Settings } from \"./json-convert-options\";\n/**\n * Offers a simple API for mapping JSON objects to TypeScript/JavaScript classes and vice versa.\n *\n * @see https://www.npmjs.com/package/json2typescript full documentation on NPM\n */\nvar JsonConvert = /** @class */ (function () {\n    /////////////////\n    // CONSTRUCTOR //\n    /////////////////\n    /**\n     * Constructor.\n     *\n     * To learn more about the params, check the documentation of the equally named class properties.\n     *\n     * @param operationMode optional param (default: OperationMode.ENABLE)\n     * @param valueCheckingMode optional param (default: ValueCheckingMode.ALLOW_OBJECT_NULL)\n     * @param ignorePrimitiveChecks optional param (default: false)\n     * @param propertyMatchingRule optional param (default: PropertyMatchingRule.CASE_STRICT)\n     */\n    function JsonConvert(operationMode, valueCheckingMode, ignorePrimitiveChecks, propertyMatchingRule) {\n        ////////////////\n        // PROPERTIES //\n        ////////////////\n        /**\n         * Determines how the JsonConvert class instance should operate.\n         *\n         * You may assign three different values:\n         * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n         * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n         * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n         */\n        this._operationMode = OperationMode.ENABLE;\n        /**\n         * Determines which types are allowed to be null.\n         * This setting may be overridden by property settings (see PropertyConvertingMode).\n         *\n         * You may assign three different values:\n         * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n         * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n         * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n         */\n        this._valueCheckingMode = ValueCheckingMode.ALLOW_OBJECT_NULL;\n        /**\n         * Determines whether a missing or undefined property value should be considered as null or not.\n         *\n         * If true, a missing JSON value will be added and set as null before deserialization.\n         * For serialization, undefined values will be set to null before serialization.\n         *\n         * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n         * serialization or deserialization.\n         */\n        this._mapUndefinedToNull = false;\n        /**\n         * Determines whether primitive types should be checked.\n         * If true, it will be allowed to assign primitive to other primitive types.\n         */\n        this._ignorePrimitiveChecks = false;\n        /**\n         * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n         *\n         * You may assign the following values:\n         * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n         * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n         * are not case sensitive\n         */\n        this._propertyMatchingRule = PropertyMatchingRule.CASE_STRICT;\n        /**\n         * Determines how nullable property types should be serialized and deserialized.\n         * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n         *\n         * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n         *\n         * The values should be used as follows:\n         * Determines how nullable property types should be serialized and deserialized.\n         * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n         *\n         * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n         *\n         * The values should be used as follows:\n         * - MAP_NULLABLE: the mapper is applied, type is checked\n         * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * not added to the result\n         * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * added with its value to the result\n         */\n        this._propertyConvertingMode = undefined;\n        /**\n         * Determines if discriminators should be used.\n         * If this option is set to true, all registered classes will be serialized with an additional discriminator\n         * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n         * When deserializing an object containing the discriminator property, json2typescript will attempt to\n         * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n         * registered classes).\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        this._useDiscriminator = false;\n        /**\n         * Defines the name of the discriminator property.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        this._discriminatorPropertyName = \"$type\";\n        /**\n         * Determines all classes which should use the discriminator feature.\n         * Only classes provided here can be enriched with the discriminator property.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        this._classes = new Map();\n        if (operationMode !== undefined && operationMode in OperationMode)\n            this.operationMode = operationMode;\n        if (valueCheckingMode !== undefined && valueCheckingMode in ValueCheckingMode)\n            this.valueCheckingMode = valueCheckingMode;\n        if (ignorePrimitiveChecks !== undefined)\n            this.ignorePrimitiveChecks = ignorePrimitiveChecks;\n        if (propertyMatchingRule !== undefined)\n            this.propertyMatchingRule = propertyMatchingRule;\n    }\n    Object.defineProperty(JsonConvert.prototype, \"operationMode\", {\n        /**\n         * Determines how the JsonConvert class instance should operate.\n         *\n         * You may assign three different values:\n         * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n         * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n         * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._operationMode;\n        },\n        /**\n         * Determines how the JsonConvert class instance should operate.\n         *\n         * You may assign three different values:\n         * - OperationMode.DISABLE: json2typescript will be disabled, no type checking or mapping is done\n         * - OperationMode.ENABLE: json2typescript is enabled, but only errors are logged\n         * - OperationMode.LOGGING: json2typescript is enabled and detailed information is logged\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            if (value in OperationMode)\n                this._operationMode = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"valueCheckingMode\", {\n        /**\n         * Determines which types are allowed to be null.\n         * This setting may be overridden by property settings (see PropertyConvertingMode).\n         *\n         * You may assign three different values:\n         * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n         * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n         * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._valueCheckingMode;\n        },\n        /**\n         * Determines which types are allowed to be null.\n         * This setting may be overridden by property settings (see PropertyConvertingMode).\n         *\n         * You may assign three different values:\n         * - ValueCheckingMode.ALLOW_NULL: all given values are allowed to be null\n         * - ValueCheckingMode.ALLOW_OBJECT_NULL: objects are allowed to be null, primitive types are not allowed to be null\n         * - ValueCheckingMode.DISALLOW_NULL: no null values are tolerated\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            if (value in ValueCheckingMode)\n                this._valueCheckingMode = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"mapUndefinedToNull\", {\n        /**\n         * Determines whether a missing or undefined property value should be considered as null or not.\n         *\n         * If true, a missing JSON value will be added and set as null before deserialization.\n         * For serialization, undefined values will be set to null before serialization.\n         *\n         * ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n         * serialization or deserialization.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._mapUndefinedToNull;\n        },\n        /**\n         * Determines whether a missing or undefined property value should be considered as null or not.\n         *\n         * If true, a missing JSON value will be added and set as null before deserialization.\n         * For serialization, undefined values will be set to null before serialization.\n         *\n         * The ValueCheckingMode and PropertyConvertingMode determine whether an error will be thrown during\n         * serialization or deserialization.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            this._mapUndefinedToNull = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"ignorePrimitiveChecks\", {\n        /**\n         * Determines whether primitive types should be checked.\n         * If true, it will be allowed to assign primitive to other primitive types.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._ignorePrimitiveChecks;\n        },\n        /**\n         * Determines whether primitive types should be checked.\n         * If true, it will be allowed to assign primitive to other primitive types.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            this._ignorePrimitiveChecks = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"propertyMatchingRule\", {\n        /**\n         * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n         *\n         * You may assign the following values:\n         * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n         * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n         * are not case sensitive\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._propertyMatchingRule;\n        },\n        /**\n         * Determines the rule of how JSON properties shall be matched with class properties during deserialization.\n         *\n         * You may assign the following values:\n         * - PropertyMatchingRule.CASE_STRICT: JSON properties need to match exactly the names in the decorators\n         * - PropertyMatchingRule.CASE_INSENSITIVE: JSON properties need to match names in the decorators, but names they\n         * are not case sensitive\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            if (value in PropertyMatchingRule)\n                this._propertyMatchingRule = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"propertyConvertingMode\", {\n        /**\n         * Determines how nullable property types should be serialized and deserialized.\n         * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n         *\n         * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n         *\n         * The values should be used as follows:\n         * - MAP_NULLABLE: the mapper is applied, type is checked\n         * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * not added to the result\n         * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * added with its value to the result\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._propertyConvertingMode;\n        },\n        /**\n         * Determines how nullable property types should be serialized and deserialized.\n         * Nullable types are either missing (in JSON), undefined (in TypeScript) or null (both).\n         *\n         * If the propertyConvertingMode has a non-undefined value, it overrides the individual settings of every property.\n         *\n         * The values should be used as follows:\n         * - MAP_NULLABLE: the mapper is applied, type is checked\n         * - IGNORE_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * not added to the result\n         * - PASS_NULLABLE: the mapper is not applied if the property is missing, undefined or null; the property is\n         * added with its value to the result\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            this._propertyConvertingMode = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"ignoreRequiredCheck\", {\n        /**\n         * @deprecated\n         */\n        get: function () {\n            return this.propertyConvertingMode === PropertyConvertingMode.IGNORE_NULLABLE;\n        },\n        /**\n         * @deprecated\n         */\n        set: function (value) {\n            this.propertyConvertingMode = value ? PropertyConvertingMode.IGNORE_NULLABLE : undefined;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"useDiscriminator\", {\n        /**\n         * Determines if discriminators should be used.\n         * If this option is set to true, all registered classes will be serialized with an additional discriminator\n         * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n         * When deserializing an object containing the discriminator property, json2typescript will attempt to\n         * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n         * registered classes).\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._useDiscriminator;\n        },\n        /**\n         * Determines if discriminators should be used.\n         * If this option is set to true, all registered classes will be serialized with an additional discriminator\n         * property (default: \"$type\"), which has the key of the class (given in the @JsonObject decorator) as value.\n         * When deserializing an object containing the discriminator property, json2typescript will attempt to\n         * automatically instantiate the correct type (by comparing the value of the discriminator property with the\n         * registered classes).\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            this._useDiscriminator = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"discriminatorPropertyName\", {\n        /**\n         * Defines the name of the discriminator property.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._discriminatorPropertyName;\n        },\n        /**\n         * Defines the name of the discriminator property.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        set: function (value) {\n            this._discriminatorPropertyName = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(JsonConvert.prototype, \"classes\", {\n        /**\n         * Determines all classes which should use the discriminator feature.\n         * Only classes provided here can be enriched with the discriminator property.\n         *\n         * @see https://www.npmjs.com/package/json2typescript full documentation\n         */\n        get: function () {\n            return this._classes;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ////////////////////\n    // PUBLIC METHODS //\n    ////////////////////\n    /**\n     * Registers a list of classes to be used in the discriminator feature.\n     * After registering these classes, they may be used for the discriminator feature.\n     *\n     * @param classReferences the class references\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.registerClasses = function () {\n        var _this = this;\n        var classReferences = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            classReferences[_i] = arguments[_i];\n        }\n        classReferences.forEach(function (classReference) {\n            var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n            if (key) {\n                _this.classes.set(key, classReference);\n            }\n        });\n    };\n    /**\n     * Unregisters a list of classes from the discriminator feature.\n     * After unregistering these classes, they cannot be used anymore for the discriminator feature.\n     *\n     * @param classReferences the class references\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.unregisterClasses = function () {\n        var _this = this;\n        var classReferences = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            classReferences[_i] = arguments[_i];\n        }\n        classReferences.forEach(function (classReference) {\n            var key = classReference.prototype[Settings.CLASS_IDENTIFIER] || classReference.name;\n            _this.classes.delete(key);\n        });\n    };\n    /**\n     * Unregisters all classes from discriminator feature.\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.unregisterAllClasses = function () {\n        this.classes.clear();\n    };\n    /**\n     * Tries to serialize a TypeScript object or array of objects to JSON using the mappings defined on\n     * the specified class reference. Note that if a class reference is provided, it will be used as\n     * the source of property mapping for serialization, even if the object or one of its elements is\n     * an instance of a different class with its own mappings.  Also, ONLY the properties from the\n     * class reference will be serialized - any additional properties on the object(s) will be silently\n     * ignored.\n     *\n     * @param data object or array of objects\n     * @param classReference the class reference which provides the property mappings to use\n     *\n     * @returns the JSON object\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.serialize = function (data, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return data;\n        }\n        // Call the appropriate method depending on the type\n        if (data instanceof Array) {\n            return this.serializeArray(data, classReference);\n        }\n        else if (typeof data === \"object\") { // careful: an array is an object in TypeScript!\n            return this.serializeObject(data, classReference);\n        }\n        else {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter data in JsonConvert.serialize() is not in valid format (object or array).\" +\n                \"\\n\");\n        }\n    };\n    /**\n     * Tries to serialize a TypeScript object to a JSON object using either the mappings on the\n     * provided class reference, if present, or on the provided object. Note that if a class\n     * reference is provided, it will be used as the source of property mapping for serialization,\n     * even if the object is itself an instance of a different class with its own mappings.\n     * Also, ONLY the properties from the class reference will be serialized - any additional\n     * properties on the object will be silently ignored.\n     *\n     * @param data object containing the values to be mapped to a JSON object, must be an\n     *             instance of a class with JSON mappings if no class reference is provided\n     * @param classReference optional class reference which provides the property mappings to use\n     *\n     * @returns the JSON object\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.serializeObject = function (data, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return data;\n        }\n        data = this.mapUndefinedToNull && data === undefined ? null : data;\n        // Check if the passed type is allowed\n        if (data === undefined) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter instance in JsonConvert.serializeObject() is undefined. This is not a valid JSON format.\" +\n                \"\\n\");\n        }\n        else if (data === null) {\n            if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n                throw new Error(\"Fatal error in JsonConvert. \" +\n                    \"Passed parameter instance in JsonConvert.serializeObject() is null. You have specified to \" +\n                    \"disallow null values.\" +\n                    \"\\n\");\n            }\n            else {\n                return data;\n            }\n        }\n        else if (typeof (data) !== \"object\" || data instanceof Array) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter instance in JsonConvert.serializeObject() is not of type object.\" +\n                \"\\n\");\n        }\n        // Now serialize and return the plain object\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"----------\");\n            console.log(\"Receiving JavaScript instance:\");\n            console.log(data);\n        }\n        var jsonObject = {};\n        var instance;\n        if (!!classReference) {\n            instance = new classReference();\n        }\n        else {\n            instance = data;\n        }\n        // Loop through all initialized class properties on the mapping instance\n        for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n            var propertyKey = _a[_i];\n            try {\n                this.serializeObject_loopProperty(data, instance, propertyKey, jsonObject);\n            }\n            catch (ex) {\n                if (this.operationMode === OperationMode.LOGGING) {\n                    console.log(\"Failed to serialize property:\");\n                    console.log(ex);\n                    console.log(\"----------\");\n                }\n                throw ex;\n            }\n        }\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"Returning JSON object:\");\n            console.log(jsonObject);\n            console.log(\"----------\");\n        }\n        return jsonObject;\n    };\n    /**\n     * Tries to serialize a TypeScript array to a JSON array using either the mappings on the\n     * provided class reference, if present, or on the provided object. Note that if a class\n     * reference is provided, ALL objects in the array will be serialized using the mappings\n     * from that class reference, even if they're actually instances of a different class.\n     * Also, ONLY the properties from the class reference will be serialized - any additional\n     * properties on the objects will be silently ignored.\n     *\n     * @param dataArray array of objects containing the values to be mapped to a JSON object, which\n     *                  must be instances of classes with JSON mappings if no class reference is provided\n     * @param classReference optional class reference which provides the property mappings to use\n     *\n     * @returns the JSON array\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.serializeArray = function (dataArray, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return dataArray;\n        }\n        dataArray = this.mapUndefinedToNull && dataArray === undefined ? null : dataArray;\n        // Check if the passed type is allowed\n        if (dataArray === undefined) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter instanceArray in JsonConvert.serializeArray() is undefined. This is not a valid JSON format.\" +\n                \"\\n\");\n        }\n        else if (dataArray === null) {\n            if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n                throw new Error(\"Fatal error in JsonConvert. \" +\n                    \"Passed parameter instanceArray in JsonConvert.serializeArray() is null. You have specified to \" +\n                    \"disallow null values.\" +\n                    \"\\n\");\n            }\n            else {\n                return dataArray;\n            }\n        }\n        else if (typeof (dataArray) !== \"object\" || dataArray instanceof Array === false) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter instanceArray in JsonConvert.serializeArray() is not of type array.\" +\n                \"\\n\");\n        }\n        // Now serialize and return the plain object\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"----------\");\n            console.log(\"Receiving JavaScript array:\");\n            console.log(dataArray);\n        }\n        var jsonArray = [];\n        // Loop through all array elements\n        for (var _i = 0, dataArray_1 = dataArray; _i < dataArray_1.length; _i++) {\n            var dataObject = dataArray_1[_i];\n            jsonArray.push(this.serializeObject(dataObject, classReference));\n        }\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"Returning JSON array:\");\n            console.log(jsonArray);\n            console.log(\"----------\");\n        }\n        return jsonArray;\n    };\n    /**\n     * Tries to deserialize given JSON to a TypeScript object or array of objects.\n     *\n     * @param json the JSON as object or array\n     * @param classReference the class reference\n     *\n     * @returns the deserialized data (TypeScript instance or array of TypeScript instances)\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.deserialize = function (json, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return json;\n        }\n        // Call the appropriate method depending on the type\n        if (json instanceof Array) {\n            return this.deserializeArray(json, classReference);\n        }\n        else if (typeof json === \"object\") { // careful: an array is an object in TypeScript!\n            return this.deserializeObject(json, classReference);\n        }\n        else {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter json in JsonConvert.deserialize() is not in valid JSON format (object or array).\" +\n                \"\\n\");\n        }\n    };\n    /**\n     * Tries to deserialize a JSON object to a TypeScript object.\n     *\n     * @param jsonObject the JSON object\n     * @param classReference the class reference\n     *\n     * @returns the deserialized TypeScript instance\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.deserializeObject = function (jsonObject, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return jsonObject;\n        }\n        jsonObject = this.mapUndefinedToNull && jsonObject === undefined ? null : jsonObject;\n        // Check if the passed type is allowed\n        if (jsonObject === undefined) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter jsonObject in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" +\n                \"\\n\");\n        }\n        else if (jsonObject === null) {\n            if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n                throw new Error(\"Fatal error in JsonConvert. \" +\n                    \"Passed parameter jsonObject in JsonConvert.deserializeObject() is null. You have specified to \" +\n                    \"disallow null values.\" +\n                    \"\\n\");\n            }\n            else {\n                return jsonObject;\n            }\n        }\n        else if (typeof (jsonObject) !== \"object\" || jsonObject instanceof Array) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter jsonObject in JsonConvert.deserializeObject() is not of type object.\" +\n                \"\\n\");\n        }\n        // Now deserialize and return the instance\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"----------\");\n            console.log(\"Receiving JSON object:\");\n            console.log(jsonObject);\n        }\n        var instance = new classReference();\n        // Loop through all initialized class properties\n        for (var _i = 0, _a = Object.keys(instance); _i < _a.length; _i++) {\n            var propertyKey = _a[_i];\n            try {\n                this.deserializeObject_loopProperty(instance, propertyKey, jsonObject);\n            }\n            catch (ex) {\n                if (this.operationMode === OperationMode.LOGGING) {\n                    console.log(\"Failed to deserialize property:\");\n                    console.log(ex);\n                    console.log(\"----------\");\n                }\n                throw ex;\n            }\n        }\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"Returning CLASS instance:\");\n            console.log(instance);\n            console.log(\"----------\");\n        }\n        return instance;\n    };\n    /**\n     * Tries to deserialize a JSON array to a TypeScript array.\n     *\n     * @param jsonArray the JSON array\n     * @param classReference the object class\n     *\n     * @returns the deserialized array of TypeScript instances\n     *\n     * @throws an Error in case of failure\n     *\n     * @see https://www.npmjs.com/package/json2typescript full documentation\n     */\n    JsonConvert.prototype.deserializeArray = function (jsonArray, classReference) {\n        if (this.operationMode === OperationMode.DISABLE) {\n            return jsonArray;\n        }\n        jsonArray = this.mapUndefinedToNull && jsonArray === undefined ? null : jsonArray;\n        // Check if the passed type is allowed\n        if (jsonArray === undefined) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter jsonArray in JsonConvert.deserializeObject() is undefined. This is not a valid JSON format.\" +\n                \"\\n\");\n        }\n        else if (jsonArray === null) {\n            if (this.valueCheckingMode === ValueCheckingMode.DISALLOW_NULL) {\n                throw new Error(\"Fatal error in JsonConvert. \" +\n                    \"Passed parameter jsonArray in JsonConvert.deserializeObject() is null. You have specified to \" +\n                    \"disallow null values.\" +\n                    \"\\n\");\n            }\n            else {\n                return jsonArray;\n            }\n        }\n        else if (typeof (jsonArray) !== \"object\" || jsonArray instanceof Array === false) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Passed parameter jsonArray in JsonConvert.deserializeArray() is not of type array.\" +\n                \"\\n\");\n        }\n        // Now deserialize and return the array\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"----------\");\n            console.log(\"Receiving JSON array:\");\n            console.log(jsonArray);\n        }\n        var array = [];\n        // Loop through all array elements\n        for (var _i = 0, jsonArray_1 = jsonArray; _i < jsonArray_1.length; _i++) {\n            var jsonObject = jsonArray_1[_i];\n            array.push(this.deserializeObject(jsonObject, classReference));\n        }\n        if (this.operationMode === OperationMode.LOGGING) {\n            console.log(\"Returning array of CLASS instances:\");\n            console.log(array);\n            console.log(\"----------\");\n        }\n        return array;\n    };\n    /////////////////////\n    // PRIVATE METHODS //\n    /////////////////////\n    /**\n     * Tries to find the JSON mapping for a given class property from the given instance used for mapping,\n     * and finally assign the value from the given dataObject\n     *\n     * @param dataObject the object containing the value to be assigned\n     * @param instance the instance of the class used for mapping\n     * @param classPropertyName the property name\n     * @param json the JSON object\n     * @throws throws an Error in case of failure\n     */\n    JsonConvert.prototype.serializeObject_loopProperty = function (dataObject, instance, classPropertyName, json) {\n        var _this = this;\n        var _a, _b;\n        // Check if a JSON-object mapping is possible for a property\n        var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n        if (mappingOptions === null) {\n            return;\n        }\n        // Get expected and real values\n        var jsonPropertyName = mappingOptions.jsonPropertyName;\n        var expectedJsonType = mappingOptions.expectedJsonType;\n        var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n        var customConverter = mappingOptions.customConverter;\n        var classInstancePropertyValue = dataObject[classPropertyName];\n        // Check if we have a nullable type\n        classInstancePropertyValue = this.mapUndefinedToNull && classInstancePropertyValue === undefined ? null : classInstancePropertyValue;\n        if (classInstancePropertyValue === undefined || classInstancePropertyValue === null) {\n            if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n                return;\n            }\n            if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n                json[jsonPropertyName] = classInstancePropertyValue;\n                return;\n            }\n        }\n        // Map the property\n        try {\n            json[jsonPropertyName] = customConverter !== null ?\n                customConverter.serialize(classInstancePropertyValue) :\n                this.convertProperty(expectedJsonType, classInstancePropertyValue, convertingMode, true);\n            var classConstructorName_1 = (_b = dataObject === null || dataObject === void 0 ? void 0 : dataObject.constructor) === null || _b === void 0 ? void 0 : _b.name;\n            if (this._useDiscriminator && json instanceof Object) {\n                this.classes.forEach(function (classDataObject, key) {\n                    if (classDataObject.name === classConstructorName_1) {\n                        json[_this._discriminatorPropertyName] = key;\n                    }\n                });\n            }\n        }\n        catch (e) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Failed to map the JavaScript instance of class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" to JSON because of a type error.\\n\\n\" +\n                \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" +\n                \"\\tClass property value: \\n\\t\\t\" + classInstancePropertyValue + \"\\n\\n\" +\n                \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" +\n                \"\\tRuntime type: \\n\\t\\t\" + this.getTrueType(classInstancePropertyValue) + \"\\n\\n\" +\n                \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" +\n                e.message + \"\\n\");\n        }\n    };\n    /**\n     * Tries to find the JSON mapping for a given class property and finally assign the value.\n     *\n     * @param instance the instance of the class\n     * @param classPropertyName the property name\n     * @param json the JSON object\n     *\n     * @throws throws an Error in case of failure\n     */\n    JsonConvert.prototype.deserializeObject_loopProperty = function (instance, classPropertyName, json) {\n        var _a;\n        var mappingOptions = this.getClassPropertyMappingOptions(instance, classPropertyName);\n        if (mappingOptions === null) {\n            return;\n        }\n        // Get expected and real values\n        var jsonPropertyName = mappingOptions.jsonPropertyName;\n        var expectedJsonType = mappingOptions.expectedJsonType;\n        var convertingMode = (_a = this.propertyConvertingMode) !== null && _a !== void 0 ? _a : mappingOptions.convertingMode;\n        var customConverter = mappingOptions.customConverter;\n        var jsonValue = undefined;\n        try {\n            jsonValue = this.getObjectValue(json, jsonPropertyName);\n        }\n        catch (_b) { }\n        // Check if we have a nullable type\n        jsonValue = this.mapUndefinedToNull && jsonValue === undefined ? null : jsonValue;\n        if (jsonValue === undefined || jsonValue === null) {\n            if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n                return;\n            }\n            if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n                instance[classPropertyName] = jsonValue;\n                return;\n            }\n        }\n        // Map the property\n        try {\n            var classConstructorName = jsonValue instanceof Object ? jsonValue[this.discriminatorPropertyName] : null;\n            if (this._useDiscriminator && this.classes.has(classConstructorName)) {\n                expectedJsonType = this.classes.get(classConstructorName);\n            }\n            instance[classPropertyName] = customConverter !== null ?\n                customConverter.deserialize(jsonValue) :\n                this.convertProperty(expectedJsonType, jsonValue, convertingMode);\n        }\n        catch (e) {\n            throw new Error(\"Fatal error in JsonConvert. \" +\n                \"Failed to map the JSON object to the class \\\"\" + instance[Settings.CLASS_IDENTIFIER] + \"\\\" because of a type error.\\n\\n\" +\n                \"\\tClass property: \\n\\t\\t\" + classPropertyName + \"\\n\\n\" +\n                \"\\tExpected type: \\n\\t\\t\" + this.getExpectedType(expectedJsonType) + \"\\n\\n\" +\n                \"\\tJSON property: \\n\\t\\t\" + jsonPropertyName + \"\\n\\n\" +\n                \"\\tJSON type: \\n\\t\\t\" + this.getJsonType(jsonValue) + \"\\n\\n\" +\n                \"\\tJSON value: \\n\\t\\t\" + JSON.stringify(jsonValue) + \"\\n\\n\" +\n                e.message + \"\\n\");\n        }\n    };\n    ////////////////////\n    // HELPER METHODS //\n    ////////////////////\n    /**\n     * Gets the mapping options of a given class property.\n     *\n     * @param instance any class instance\n     * @param {string} propertyName any property name\n     *\n     * @returns {MappingOptions|null}\n     */\n    JsonConvert.prototype.getClassPropertyMappingOptions = function (instance, propertyName) {\n        var mappings = instance[Settings.MAPPING_PROPERTY];\n        // Check if mapping is defined\n        if (typeof (mappings) === \"undefined\")\n            return null;\n        /* Find mapping by iterating up the prototype chain to find a matching mapping, rather than\n         * just searching by property name. */\n        var prototype = Object.getPrototypeOf(instance);\n        /* According to documentation, we'll hit null when we've iterated all the way up to the base\n         * Object, but check for undefined as well in case prototype has been manually set to\n         * undefined. Note that javascript detects circular prototype references and will cause a\n         * TypeError, so no need to check for self, the prototype chain will eventually terminate. */\n        while (prototype !== null && prototype !== undefined) {\n            var classIdentifier = prototype[Settings.CLASS_IDENTIFIER];\n            if (!!classIdentifier) {\n                var mappingName = classIdentifier + \".\" + propertyName;\n                if (typeof (mappings[mappingName]) !== \"undefined\") {\n                    return mappings[mappingName];\n                }\n            }\n            prototype = Object.getPrototypeOf(prototype);\n        }\n        return null;\n    };\n    /**\n     * Compares the type of a given value with an internal expected json type.\n     * Either returns the resulting value or throws an exception.\n     *\n     * @param expectedType the expected type for the property\n     * @param value the property value to verify\n     * @param convertingMode the converting mode for this property\n     * @param serialize optional param (default: false), if given, we are in serialization mode\n     *\n     * @returns returns the resulted mapped property\n     *\n     * @throws an error in case of failure\n     */\n    JsonConvert.prototype.convertProperty = function (expectedType, value, convertingMode, serialize) {\n        ////////////////////////////\n        // Prior checks and setup //\n        ////////////////////////////\n        // Return the value immediately if we don't care about the type\n        if (expectedType === undefined || expectedType === Any || expectedType === null || expectedType === Object) {\n            return value;\n        }\n        // Check if we have a nullable type\n        value = this.mapUndefinedToNull && value === undefined ? null : value;\n        if (value === undefined || value === null) {\n            if (convertingMode === PropertyConvertingMode.IGNORE_NULLABLE) {\n                return undefined;\n            }\n            if (convertingMode === PropertyConvertingMode.PASS_NULLABLE) {\n                return value;\n            }\n        }\n        var expectedDimension = \"1\";\n        if (expectedType instanceof Array) {\n            expectedDimension = \"2\";\n        }\n        var valueDimension = \"1or2\";\n        if (value instanceof Array) {\n            valueDimension = \"2\";\n        }\n        else if (!(value instanceof Object)) {\n            valueDimension = \"1\";\n        }\n        if (expectedDimension === \"1\" && valueDimension === \"2\") {\n            throw new Error(\"\\tReason: Expected a non-array type, but given value is an array.\");\n        }\n        if (expectedDimension === \"2\" && valueDimension === \"1\") {\n            // Allow to use null in the special case\n            if (value === null && this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n                return null;\n            }\n            else if (value === null) {\n                throw new Error(\"\\tReason: Expected an array, but given value is null.\");\n            }\n            throw new Error(\"\\tReason: Expected an array, but given value is a primitive type.\");\n        }\n        //////////////////\n        // Check values //\n        //////////////////\n        if (expectedDimension === \"2\" && (valueDimension === \"2\" || valueDimension === \"1or2\")) {\n            // Return an empty array if we have an empty array or object as value\n            if (value.length === 0 || Object.keys(value).length === 0) {\n                return [];\n            }\n            // Return the value if we don't care about the array type\n            if (expectedType.length === 0) {\n                return value;\n            }\n            // Copy the expectedJsonType array so we don't change the class-level mapping based on the value of this property\n            var jsonType = expectedType.slice(0);\n            var array = [];\n            if (valueDimension === \"2\") {\n                // Loop through the data. Both type and value are at least of length 1\n                var autofillType = jsonType.length < value.length;\n                for (var i = 0; i < value.length; i++) {\n                    if (autofillType && i >= jsonType.length) {\n                        jsonType[i] = jsonType[i - 1];\n                    }\n                    array[i] = this.convertProperty(jsonType[i], value[i], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n                }\n                return array;\n            }\n            else {\n                // Loop through the data. Both type and value are at least of length 1\n                var autofillType = jsonType.length < Object.keys(value).length;\n                var i = 0;\n                for (var key in value) {\n                    if (autofillType && i >= jsonType.length) {\n                        jsonType[i] = jsonType[i - 1];\n                    }\n                    array[key] = this.convertProperty(jsonType[i], value[key], this.propertyConvertingMode || PropertyConvertingMode.MAP_NULLABLE, serialize);\n                    i++;\n                }\n                return array;\n            }\n        }\n        else if (expectedDimension === \"1\" && (valueDimension === \"1\" || valueDimension === \"1or2\")) {\n            // Check if objects match\n            if (expectedType instanceof Object && value instanceof Object) {\n                if (expectedType.prototype.hasOwnProperty(Settings.CLASS_IDENTIFIER)) {\n                    return serialize ?\n                        this.serializeObject(value, expectedType) :\n                        this.deserializeObject(value, expectedType);\n                }\n                else {\n                    return value;\n                }\n            }\n            else {\n                // Check for null values\n                if (value === null) {\n                    if (expectedType === String || expectedType === Number || expectedType === Boolean) {\n                        if (this.valueCheckingMode === ValueCheckingMode.ALLOW_NULL) {\n                            return null;\n                        }\n                        else {\n                            throw new Error(\"\\tReason: Given value null does not match the expected primitive type.\");\n                        }\n                    }\n                    else {\n                        if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) {\n                            return null;\n                        }\n                        else {\n                            throw new Error(\"\\tReason: Given value null does not match the expected object type.\");\n                        }\n                    }\n                }\n                // Check for primitive matches\n                if ((expectedType === String && typeof (value) === \"string\") ||\n                    (expectedType === Number && typeof (value) === \"number\") ||\n                    (expectedType === Boolean && typeof (value) === \"boolean\")) {\n                    return value;\n                }\n                else {\n                    if (this.ignorePrimitiveChecks)\n                        return value;\n                    throw new Error(\"\\tReason: Given value type does not match the expected primitive type.\");\n                }\n            }\n        }\n        console.log(\"---------2\");\n        console.log(expectedDimension);\n        console.log(expectedType);\n        console.log(valueDimension);\n        console.log(value);\n        // All other attempts are fatal\n        throw new Error(\"\\tReason: Mapping failed because of an unknown error.\");\n        /*\n                // Map immediately if we don't care about the type\n                if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) {\n                    return value;\n                }\n        \n                // Map the property to null if necessary\n                if (value === undefined && this.mapUndefinedToNull) {\n                    value = null;\n                }\n        \n                // Check if attempt and expected was 1-d\n                if (expectedJsonType instanceof Array === false && value instanceof Array === false) {\n        \n                    // Check the type\n                    if (typeof (expectedJsonType) !== \"undefined\" && expectedJsonType.prototype.hasOwnProperty(Settings.CLASS_IDENTIFIER)) { // only decorated custom objects have this injected property\n        \n                        // Check if we have null value\n                        if (value === null) {\n                            if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL)\n                                return null;\n                            else throw new Error(\"\\tReason: Given value is null.\");\n                        }\n        \n                        if (serialize) return this.serializeObject(value, expectedJsonType);\n                        else return this.deserializeObject(value, expectedJsonType);\n        \n                    } else if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) { // general object\n        \n                        // Check if we have null value\n                        if (value === null) {\n                            if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL)\n                                return null;\n                            else throw new Error(\"\\tReason: Given value is null.\");\n                        }\n        \n                        return value;\n        \n                    } else if (expectedJsonType === String || expectedJsonType === Number || expectedJsonType === Boolean) { // otherwise check for a primitive type\n        \n                        // Check if we have null value\n                        if (value === null) {\n                            if (this.valueCheckingMode === ValueCheckingMode.ALLOW_NULL) return null;\n                            else throw new Error(\"\\tReason: Given value is null.\");\n                        }\n        \n                        // Check if the types match\n                        if ( // primitive types match\n                            (expectedJsonType === String && typeof (value) === \"string\") ||\n                            (expectedJsonType === Number && typeof (value) === \"number\") ||\n                            (expectedJsonType === Boolean && typeof (value) === \"boolean\")\n                        ) {\n                            return value;\n                        } else { // primitive types mismatch\n                            if (this.ignorePrimitiveChecks) return value;\n                            throw new Error(\"\\tReason: Given object does not match the expected primitive type.\");\n                        }\n        \n                    } else { // other weird types\n        \n                        throw new Error(\n                            \"\\tReason: Expected type is unknown. There might be multiple reasons for this:\\n\" +\n                            \"\\t- You are missing the decorator @JsonObject (for object mapping)\\n\" +\n                            \"\\t- You are missing the decorator @JsonConverter (for custom mapping) before your class definition\\n\" +\n                            \"\\t- Your given class is undefined in the decorator because of circular dependencies\"\n                        );\n        \n                    }\n        \n                }\n        \n                // Check if expected was n-d\n                if (expectedJsonType instanceof Array) {\n                    if (value === null) {\n                        if (this.valueCheckingMode !== ValueCheckingMode.DISALLOW_NULL) return null;\n                        else throw new Error(\"\\tReason: Given value is null.\");\n                    }\n        \n                    // Check that value is not primitive\n                    if (value instanceof Object) {\n                        let array: any[] = [];\n        \n                        // No data given, so return empty value\n                        if (value.length === 0) {\n                            return array;\n                        }\n        \n                        // We obviously don't care about the type, so return the value as is\n                        if (expectedJsonType.length === 0) {\n                            return value;\n                        }\n                        // Copy the expectedJsonType array so we don't change the class-level mapping based on the value of this property\n                        const jsonType: any[] = expectedJsonType.slice(0);\n        \n                        // Check if attempt was n-d\n                        if (value instanceof Array) {\n        \n                            // Loop through the data. Both type and value are at least of length 1\n                            let autofillType: boolean = jsonType.length < value.length;\n                            for (let i = 0; i < value.length; i++) {\n        \n                                if (autofillType && i >= jsonType.length) {\n                                    jsonType[i] = jsonType[i - 1];\n                                }\n        \n                                array[i] = this.verifyProperty(jsonType[i], value[i], serialize);\n        \n                            }\n        \n                            return array;\n        \n                        // Otherwise attempt was 1-d\n                        } else {\n        \n                            // Loop through the data. Both type and value are at least of length 1\n                            let autofillType: boolean = jsonType.length < Object.keys(value).length;\n                            let i = 0;\n                            for (let key in value) {\n        \n                                if (autofillType && i >= jsonType.length) {\n                                    jsonType[i] = jsonType[i - 1];\n                                }\n        \n                                array[key as any] = this.verifyProperty(jsonType[i], value[key]);\n        \n                                i++;\n                            }\n        \n                            return array;\n        \n                        }\n        \n                    } else {\n                        throw new Error(\"\\tReason: Expected type is array, but given value is primitive.\");\n                    }\n                }\n        \n                // Check if attempt was n-d and expected as 1-d\n                if (value instanceof Array) {\n                    throw new Error(\"\\tReason: Given value is array, but expected a non-array type.\");\n                }\n        \n                // All other attempts are fatal\n                throw new Error(\"\\tReason: Mapping failed because of an unknown error.\");\n        */\n    };\n    /**\n     * Gets the value of an object for a given value.\n     * If the object does not have the specific key, an Error is thrown.\n     *\n     * @param data\n     * @param key\n     *\n     * @returns returns the value\n     *\n     * @throws an Error in case of the key was not found in the object\n     */\n    JsonConvert.prototype.getObjectValue = function (data, key) {\n        // If we do not care about the case of the key, ad\n        if (this.propertyMatchingRule === PropertyMatchingRule.CASE_INSENSITIVE) {\n            // Create a mapping of the keys: keys[lowercase]=normalcase\n            var keyMapping = Object.keys(data).reduce(function (keys, key) {\n                keys[key.toLowerCase()] = key;\n                return keys;\n            }, {});\n            // Define the new key\n            key = keyMapping[key.toLowerCase()];\n        }\n        // Throw an error if the key is not in the object\n        if (key in data === false) {\n            throw new Error();\n        }\n        return data[key];\n    };\n    ///////////////////////////\n    // JSON2TYPESCRIPT TYPES //\n    ///////////////////////////\n    /**\n     * Returns a string representation of the expected json type.\n     *\n     * @param expectedJsonType the expected type given from the decorator\n     *\n     * @returns {string} the string representation\n     */\n    JsonConvert.prototype.getExpectedType = function (expectedJsonType) {\n        var type = \"\";\n        if (expectedJsonType instanceof Array) {\n            type = \"[\";\n            for (var i = 0; i < expectedJsonType.length; i++) {\n                if (i > 0)\n                    type += \",\";\n                type += this.getExpectedType(expectedJsonType[i]);\n            }\n            type += \"]\";\n            return type;\n        }\n        else {\n            if (expectedJsonType === Any || expectedJsonType === null || expectedJsonType === Object) {\n                return \"any\";\n            }\n            else if (expectedJsonType === String || expectedJsonType === Boolean || expectedJsonType === Number) {\n                return (new expectedJsonType()).constructor.name.toLowerCase();\n            }\n            else if (typeof expectedJsonType === \"function\") {\n                return (new expectedJsonType()).constructor.name;\n            }\n            else if (expectedJsonType === undefined) {\n                return \"undefined\";\n            }\n            else {\n                return \"?????\";\n            }\n        }\n    };\n    /**\n     * Returns a string representation of the JSON value type.\n     *\n     * @param jsonValue the JSON value\n     *\n     * @returns {string} the string representation\n     */\n    JsonConvert.prototype.getJsonType = function (jsonValue) {\n        if (jsonValue === null)\n            return \"null\";\n        var type = \"\";\n        if (jsonValue instanceof Array) {\n            type = \"[\";\n            for (var i = 0; i < jsonValue.length; i++) {\n                if (i > 0)\n                    type += \",\";\n                type += this.getJsonType(jsonValue[i]);\n            }\n            type += \"]\";\n            return type;\n        }\n        else {\n            return typeof (jsonValue);\n        }\n    };\n    /**\n     * Returns a string representation of the true TypeScript type.\n     *\n     * @param trueValue the true value\n     *\n     * @returns {string} the string representation\n     */\n    JsonConvert.prototype.getTrueType = function (trueValue) {\n        return typeof (trueValue);\n    };\n    return JsonConvert;\n}());\nexport { JsonConvert };\n//# sourceMappingURL=json-convert.js.map"]},"metadata":{},"sourceType":"module"}